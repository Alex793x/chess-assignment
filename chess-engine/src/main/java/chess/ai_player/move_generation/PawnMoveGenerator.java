package chess.ai_player.move_generation;

import chess.board.Board;
import chess.board.Move;
import chess.board.enums.PieceColor;
import chess.board.enums.PieceType;
import chess.exception.IllegalMoveException;

import java.util.ArrayList;
import java.util.List;

public class PawnMoveGenerator {

    private final Board board;

    public static final long WHITE_START_RANK_MASK_FOR_DOUBLE_FORWARD_MOVE = 0x000000000000FF00L;
    public static final long BLACK_START_RANK_MASK_FOR_DOUBLE_FORWARD_MOVE = 0x00FF000000000000L;

    public PawnMoveGenerator(Board board) {
        this.board = board;
    }

    /**
     * Generates all valid moves for a pawn from a specified square.
     * This method considers pawn-specific movement rules, including forward moves,
     * captures, and the possibility of an initial two-step move. It uses bitwise operations
     * to check for empty squares and captures using occupancy bitboards.
     *
     * @param square The starting square index of the pawn, ranging from 0 (a1) to 63 (h8).
     * @param color The color of the pawn (PieceColor.WHITE or PieceColor.BLACK).
     * @return A list of Move objects, each representing a valid pawn move.
     */
    public List<Move> generateMovesForPawn(int square, PieceColor color) {
        List<Move> moves = new ArrayList<>();
        long allOccupancies = board.getBitboard().getOccupancies(PieceColor.WHITE) | board.getBitboard().getOccupancies(PieceColor.BLACK);
        long enemyOccupancies = board.getBitboard().getOccupancies(color == PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE);
        long pawnBitboard = 1L << square;

        int direction = color == PieceColor.WHITE ? 8 : -8;
        int doubleStep = 2 * direction;
        int singleMoveTarget = square + direction;
        int doubleMoveTarget = square + doubleStep;
        long startRankMask = color == PieceColor.WHITE ? WHITE_START_RANK_MASK_FOR_DOUBLE_FORWARD_MOVE : BLACK_START_RANK_MASK_FOR_DOUBLE_FORWARD_MOVE;

        // Single step forward move
        if (board.isWithinBoardBounds(singleMoveTarget) && board.isSquareEmpty(singleMoveTarget, allOccupancies)) {
            moves.add(new Move(square, singleMoveTarget, PieceType.PAWN, null, color));
        }

        // Double step forward move
        if ((pawnBitboard & startRankMask) != 0 && board.isSquareEmpty(singleMoveTarget, allOccupancies) && board.isSquareEmpty(doubleMoveTarget, allOccupancies)) {
            moves.add(new Move(square, doubleMoveTarget, PieceType.PAWN, null, color));
        }

        // Capture moves to the left and right
        int[] captureOffsets = color == PieceColor.WHITE ? new int[]{-7, 9} : new int[]{-9, 7};
        for (int offset : captureOffsets) {
            int captureSquare = square + offset;
            if (board.isWithinBoardBounds(captureSquare) && board.isSquareOccupiedByEnemy(captureSquare, enemyOccupancies)) {
                PieceType capturedPieceType = board.getPieceTypeAtSquare(captureSquare);
                moves.add(new Move(square, captureSquare, PieceType.PAWN, capturedPieceType, color));
            }
        }

        return moves;
    }

    /**
     * Moves the pawn from one square to another if the move is valid.
     * This method first checks if the intended move is within the list of valid moves
     * generated by `generateMovesForPawn`. If the move is valid, it updates the board
     * state by moving the pawn to the new square. If the move is not valid, it throws
     * an exception.
     *
     * @param fromSquare the current square index of the pawn.
     * @param toSquare the target square index to move the pawn to.
     * @param color the color of the pawn (PieceColor.WHITE or PieceColor.BLACK).
     * @throws IllegalMoveException if the move is not valid, with a message explaining why.
     */
    public void movePawn(int fromSquare, int toSquare, PieceColor color) throws IllegalMoveException {
        List<Move> validMoves = generateMovesForPawn(fromSquare, color);
        Move intendedMove = new Move(fromSquare, toSquare, PieceType.PAWN, board.getPieceTypeAtSquare(toSquare), color);

        if (validMoves.contains(intendedMove)) {
            board.getBitboard().removePieceFromSquare(fromSquare, PieceType.PAWN, color);
            board.getBitboard().placePieceOnSquare(toSquare, PieceType.PAWN, color);
            //System.out.println("Move successful: Pawn moved from " + fromSquare + " to " + toSquare);
        } else {
            throw new IllegalMoveException("Invalid move: Pawn cannot move from " + fromSquare + " to " + toSquare);
        }
    }
}
