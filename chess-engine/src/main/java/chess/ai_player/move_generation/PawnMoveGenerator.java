package chess.ai_player.move_generation;

import chess.board.Board;
import chess.board.enums.PieceColor;
import chess.board.enums.PieceType;
import chess.exception.IllegalMoveException;

import java.util.ArrayList;
import java.util.List;

public class PawnMoveGenerator {

    private final Board board;

    public static final long WHITE_START_RANK_MASK_FOR_DOUBLE_FORWARD_MOVE = 0x000000000000FF00L;
    public static final long BLACK_START_RANK_MASK_FOR_DOUBLE_FORWARD_MOVE = 0x00FF000000000000L;

    public PawnMoveGenerator(Board board) {
        this.board = board;
    }

    /**
     * Generates all valid moves for a pawn from a specified square.
     * This method considers pawn-specific movement rules, including forward moves,
     * captures, and the possibility of an initial two-step move. It uses bitwise operations
     * to check for empty squares directly using occupancy bitboards.
     *
     * @param square The starting square index of the pawn, ranging from 0 (a1) to 63 (h8).
     * @param color The color of the pawn (PieceColor.WHITE or PieceColor.BLACK).
     * @return A list of integers, each representing a valid destination square index for the pawn.
     */
    public List<Integer> generateMovesForPawn(int square, PieceColor color) {
        List<Integer> moves = new ArrayList<>();
        long allOccupancies = board.getBitboard().getOccupancies(PieceColor.WHITE) | board.getBitboard().getOccupancies(PieceColor.BLACK);
        long enemyOccupancies = board.getBitboard().getOccupancies(color == PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE);
        long pawnBitboard = 1L << square;

        int direction = color == PieceColor.WHITE ? 8 : -8;
        long singleMoveTarget = color == PieceColor.WHITE ? pawnBitboard << 8 : pawnBitboard >>> 8;
        long doubleMoveTarget = color == PieceColor.WHITE ? pawnBitboard << 16 : pawnBitboard >>> 16;
        long startRankMask = color == PieceColor.WHITE ? WHITE_START_RANK_MASK_FOR_DOUBLE_FORWARD_MOVE : BLACK_START_RANK_MASK_FOR_DOUBLE_FORWARD_MOVE;

        // Single step forward move
        if ((singleMoveTarget & allOccupancies) == 0) {
            moves.add(square + direction);
        }

        // Double step forward move
        if ((pawnBitboard & startRankMask) != 0 && (singleMoveTarget & allOccupancies) == 0 && (doubleMoveTarget & allOccupancies) == 0) {
            moves.add(square + 2 * direction);
        }

        // Capture moves to the left and right
        long leftCaptureTarget = color == PieceColor.WHITE ? pawnBitboard << 7 : pawnBitboard >>> 9;
        long rightCaptureTarget = color == PieceColor.WHITE ? pawnBitboard << 9 : pawnBitboard >>> 7;

        if ((leftCaptureTarget & enemyOccupancies) != 0) {
            moves.add(square + direction - 1);
        }
        if ((rightCaptureTarget & enemyOccupancies) != 0) {
            moves.add(square + direction + 1);
        }

        return moves;
    }




    /**
     * Moves the pawn from one square to another if the move is valid.
     * This method checks if the intended move is within the list of valid moves
     * generated by `generateMovesForPawn`. If the move is valid, it updates the board
     * state by moving the pawn to the new square. If the move is not valid, it throws
     * an exception.
     *
     * @param fromSquare the current square index of the pawn.
     * @param toSquare the target square index to move the pawn to.
     * @param color the color of the pawn (PieceColor.WHITE or PieceColor.BLACK).
     * @throws IllegalMoveException if the move is not valid, with a message explaining why.
     */
    public void movePawn(int fromSquare, int toSquare, PieceColor color) {
        List<Integer> validMoves = generateMovesForPawn(fromSquare, color);

        if (validMoves.contains(toSquare)) {
            // Execute the move on the board
            board.getBitboard().removePieceFromSquare(fromSquare, PieceType.PAWN, color);
            board.getBitboard().placePieceOnSquare(toSquare, PieceType.PAWN, color);
            System.out.println("Move successful: Pawn moved from " + fromSquare + " to " + toSquare);
        } else {
            // If the move is not valid, throw an exception detailing the issue
            throw new IllegalMoveException("Invalid move: Pawn cannot move from " + fromSquare + " to " + toSquare);
        }
    }


}