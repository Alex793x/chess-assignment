package chess.ai_player.move_generation;

import chess.board.Board;
import chess.board.enums.PieceColor;
import chess.board.enums.PieceType;
import chess.exception.IllegalMoveException;

import java.util.ArrayList;
import java.util.List;

public class PawnMoveGenerator {

    private final Board board;

    public PawnMoveGenerator(Board board) {
        this.board = board;
    }


    /**
     * Generates all valid moves for a pawn from a specified square.
     * This method considers pawn-specific movement rules, including forward moves,
     * captures, and the possibility of an initial two-step move. It uses bitwise operations
     * to check for empty squares directly using occupancy bitboards.
     *
     * @param square The starting square index of the pawn, ranging from 0 (a1) to 63 (h8).
     * @param color The color of the pawn (PieceColor.WHITE or PieceColor.BLACK).
     * @return A list of integers, each representing a valid destination square index for the pawn.
     */
    public List<Integer> generateMovesForPawn(int square, PieceColor color) {
        List<Integer> moves = new ArrayList<>();
        long allOccupancies = board.getBitboard().getOccupancies(PieceColor.WHITE) | board.getBitboard().getOccupancies(PieceColor.BLACK);
        long enemyOccupancies = board.getBitboard().getOccupancies(color == PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE);

        int direction = color == PieceColor.WHITE ? 1 : -1;
        int oneStepForward = square + 8 * direction;
        int twoStepsForward = square + 16 * direction;
        int leftCapture = square + 7 * direction;
        int rightCapture = square + 9 * direction;

        // Single step forward move
        if (board.isSquareEmpty(oneStepForward, allOccupancies)) {
            moves.add(oneStepForward);

            // Initial double step forward move
            if (((color == PieceColor.WHITE && (square / 8) == 1) ||
                    (color == PieceColor.BLACK && (square / 8) == 6)) &&
                    board.isSquareEmpty(twoStepsForward, allOccupancies)) {
                moves.add(twoStepsForward);
            }
        }

        // Capture moves to the left and right
        if (board.isWithinBoardBounds(leftCapture) && board.isSquareOccupiedByEnemy(leftCapture, enemyOccupancies)) {
            moves.add(leftCapture);
        }
        if (board.isWithinBoardBounds(rightCapture) && board.isSquareOccupiedByEnemy(rightCapture, enemyOccupancies)) {
            moves.add(rightCapture);
        }

        return moves;
    }




    /**
     * Moves the pawn from one square to another if the move is valid.
     * This method checks if the intended move is within the list of valid moves
     * generated by `generateMovesForPawn`. If the move is valid, it updates the board
     * state by moving the pawn to the new square. If the move is not valid, it throws
     * an exception.
     *
     * @param fromSquare the current square index of the pawn.
     * @param toSquare the target square index to move the pawn to.
     * @param color the color of the pawn (PieceColor.WHITE or PieceColor.BLACK).
     * @throws IllegalMoveException if the move is not valid, with a message explaining why.
     */
    public void movePawn(int fromSquare, int toSquare, PieceColor color) {
        List<Integer> validMoves = generateMovesForPawn(fromSquare, color);

        if (validMoves.contains(toSquare)) {
            // Execute the move on the board
            board.getBitboard().removePieceFromSquare(fromSquare, PieceType.PAWN, color);
            board.getBitboard().placePieceOnSquare(toSquare, PieceType.PAWN, color);
            System.out.println("Move successful: Pawn moved from " + fromSquare + " to " + toSquare);
        } else {
            // If the move is not valid, throw an exception detailing the issue
            throw new IllegalMoveException("Invalid move: Pawn cannot move from " + fromSquare + " to " + toSquare);
        }
    }


}
